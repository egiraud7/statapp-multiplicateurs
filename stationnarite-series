## Stationnariser les séries puis effectuer les tests
## Exemple du code de TD de time series de Chloé Saurel (à ajuster donc)

dates_char <- as.character(data$dates)
dates_char[1] 
tail(dates_char,1) 
dates <- as.yearmon(seq(from=1986+2/12, to=2007+3/12, by=1/12)) 
spread <- zoo(data$spread, order.by=dates)
dspread <- diff(spread,1)
plot(cbind(spread,dspread))
```

```{r}
#La série spread (en niveau) :
summary(lm(spread ~ dates))
```

```{r}
install.packages("fUnitRoots")#tests de racine unitaire plus modulables
library(fUnitRoots)
require(fUnitRoots) 
adf <- adfTest(spread, lag=0, type="ct") #
adf
```

Test avec constante et tendance :
$$
X_t = \rho*X_{t-1}+c+bt+\epsilon
$$


```{r}
#Application du test de Ljung-Box :

Qtests <- function(series, k, fitdf=0) {
  pvals <- apply(matrix(1:k), 1, FUN=function(l) {
    pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
    return(c("lag"=l,"pval"=pval))
  })
  return(t(pvals))
}
?adfTest
str(adf)
Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))
```

Ici, nous testons ADF avec 1 à 24 retards : 

```{r}
series <- spread; kmax <- 24; adftype="ct"
adfTest_valid <- function(series, kmax, adftype){
  k <- 0
  noautocorr <- 0
  while (noautocorr==0){
    cat(paste0("ADF with ",k," lags: residuals OK? "))
    adf <- adfTest(series, lags=k, type=adftype)
    pvals <- Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))[,2]
    if (sum(pvals<0.05,na.rm=T)==0) {
      noautocorr <- 1; cat("OK \n")
    } else cat("nope \n")
    k <- k+1
  }
  return(adf)
}
adf <- adfTest_valid(spread,24,adftype="ct")
```

Ici, nous observons l'autocorrélation des résidus sur le test ADF conduit avec 24 retards :
```{r}
Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))
adf
```

```{r}
#On s'intéresse maintenant à la série différenciée d'ordre 1, dspread
summary(lm(dspread ~ dates[-1]))
```

Ici, ni constante ni tendance n'est nécessaire car elles ne sont pas significativement différentes de 0.

```{r}
adf <- adfTest_valid(dspread,24,"nc")
Qtests(adf@test$lm$residuals, 24, fitdf = length(adf@test$lm$coefficients))
adf
```

```{r}
par(mfrow=c(1,2))
pacf(dspread,24);acf(dspread,24) #on regarde jusqu'? deux ans de retard
#
# 
pmax=3;qmax=3
```

```{r}
# Q5 ####
pqs <- expand.grid(0:pmax,0:qmax) #combinaisons possibles de p<=p* et q<=q*
mat <- matrix(NA, nrow=pmax+1, ncol=pmax+1)
rownames(mat) <- paste0("p=",0:pmax) #renomme les lignes
colnames(mat) <- paste0("q=",0:pmax) #renomme les colonnes
AICs <- mat #matrice ou assigner les AIC
BICs <- mat #matrice ou assigner les BIC
for (row in 1:dim(pqs)[1]){
  p <- pqs[row,1]
  q <- pqs[row,2]
  estim <- try(arima(dspread,c(p,0,q), include.mean=F)) #tente d'estimer l'ARIMA
  AICs[p+1,q+1] <- if (class(estim)=="try-error") NA else estim$aic
  BICs[p+1,q+1] <- if (class(estim)=="try-error") NA else BIC(estim)
}
AICs
BICs
AICs==min(AICs)
#
BICs==min(BICs)
#
arima310 <- arima(spread,c(3,1,0),include.mean=F)
arima011 <- arima(spread,c(0,1,1),include.mean=F)
```

```{r}
arima310
arima011

```



```{r}
Qtests(arima310$residuals, 24, fitdf=3)
Qtests(arima011$residuals, 24, fitdf=1)
```

Ici, on calcule les RMSE et le R2 ajusté et prendre le plus élevé, aui est une autre façon de trancher entre les modèles. 
```{r}
# Q9 ####
adj_r2 <- function(model){
  ss_res <- sum(model$residuals^2)
  ss_tot <- sum(dspread[-c(1:max(p,q))]^2)
  p <- model$arma[1]
  q <- model$arma[2]
  n <- model$nobs-max(p,q)
  adj_r2 <- 1-(ss_res/(n-p-q-1))/(ss_tot/(n-1))
  return(adj_r2)
}
adj_r2(arima310)
adj_r2(arima011)

dev.off()
plot(arima310$residuals)
axis(side=1,2001+11/12)
```

```{r}
breakpoint <- c(1:length(dates))[dates==1995]
ap1995 <- c(rep(0,breakpoint-1),rep(1,length(dates)-breakpoint+1))
arima(spread,c(3,1,0),xreg=ap1995,include.mean=F)
plot(dspread)
```
